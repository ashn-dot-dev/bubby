namespace bubby;
import "std";

enum type {
    BOOL;
    INT;
    NUMBER;
    STRING;
    VECTOR;
    MAP;
    SET;
}

struct value {
    var _type: type;
    var _data: union {
        var bool: bool;
        var int: s64;
        var number: f64;
        var string: []byte;
        var vector: *std::vector[[value]];
        var map: *any; # *std::hash_map[[value, value]];
        var set: *any; # *std::hash_set[[value]];
    };

    let _SELF: value = uninit;

    func init_bool(bool: bool) value {
        return (:value){
            ._type = bubby::type::BOOL,
            ._data = (:typeof(value::_SELF._data)){.bool = bool},
        };
    }

    func init_int(int: s64) value {
        return (:value){
            ._type = bubby::type::INT,
            ._data = (:typeof(value::_SELF._data)){.int = int},
        };
    }

    func init_number(number: f64) value {
        return (:value){
            ._type = bubby::type::NUMBER,
            ._data = (:typeof(value::_SELF._data)){.number = number},
        };
    }

    func init_string(string: []byte) value {
        var new = std::slice[[byte]]::new(countof(string));
        std::slice[[byte]]::copy(new, string);
        return (:value){
            ._type = bubby::type::STRING,
            ._data = (:typeof(value::_SELF._data)){.string = new},
        };
    }

    func init_vector() value {
        var new = std::new[[std::vector[[value]]]]();
        *new = std::vector[[value]]::init();
        return (:value){
            ._type = bubby::type::VECTOR,
            ._data = (:typeof(value::_SELF._data)){.vector = new},
        };
    }

    func init_map() value {
        var new = std::new[[std::hash_map[[value, value]]]]();
        *new = std::hash_map[[value, value]]::init();
        return (:value){
            ._type = bubby::type::MAP,
            ._data = (:typeof(value::_SELF._data)){.map = new},
        };
    }

    func init_set() value {
        var new = std::new[[std::hash_set[[value]]]]();
        *new = std::hash_set[[value]]::init();
        return (:value){
            ._type = bubby::type::SET,
            ._data = (:typeof(value::_SELF._data)){.set = new},
        };
    }

    func init_from_str(str: []byte) std::result[[value, std::error]] {
        var result = bubby::parse(str);
        if result.is_error() {
            return std::result[[value, std::error]]::init_error(result.error());
        }
        if result.value().index != countof(str) {
            return std::result[[value, std::error]]::init_error(std::error::PARSE_FAILURE);
        }
        return std::result[[value, std::error]]::init_value(result.value().value);
    }

    func fini(self: *value) void {
        switch self.*._type {
        bubby::type::BOOL or bubby::type::INT or bubby::type::NUMBER {
            return;
        }
        bubby::type::STRING {
            std::slice[[byte]]::delete(self.*._data.string);
            return;
        }
        bubby::type::VECTOR {
            var iter = std::slice_iterator[[value]]::init(self.*._data.vector.*.data());
            for iter.advance() {
                value::fini(iter.current());
            }
            std::vector[[value]]::fini(self.*._data.vector);
            std::delete[[std::vector[[value]]]](self.*._data.vector);
            return;
        }
        bubby::type::MAP {
            var map = self.*.map();
            var iter = std::hash_map_iterator[[value, value]]::init(map);
            for iter.advance() {
                value::fini(iter.current().*.key);
                value::fini(iter.current().*.value);
            }
            std::hash_map[[value, value]]::fini(map);
            std::delete[[std::hash_map[[value, value]]]](map);
            return;
        }
        bubby::type::SET {
            var set = self.*.set();
            var iter = std::hash_set_iterator[[value]]::init(set);
            for iter.advance() {
                value::fini(iter.current());
            }
            std::hash_set[[value]]::fini(set);
            std::delete[[std::hash_set[[value]]]](set);
            return;
        }
        }

        std::unreachable(fileof(), lineof());
    }

    func hash(self: *value) usize {
        switch self.*._type {
        bubby::type::BOOL {
            return self.*._data.bool.hash();
        }
        bubby::type::INT {
            return self.*._data.int.hash();
        }
        bubby::type::NUMBER {
            return self.*._data.number.hash();
        }
        bubby::type::STRING {
            return self.*._data.string.hash();
        }
        bubby::type::VECTOR {
            var hash = 0u;
            var iter = std::slice_iterator[[value]]::init(self.*._data.vector.*.data());
            for iter.advance() {
                hash = hash +% value::hash(iter.current());
            }
            return hash;
        }
        bubby::type::MAP {
            var map = self.*.map();
            var hash = 0u;
            var iter = std::hash_map_iterator[[value, value]]::init(map);
            for iter.advance() {
                var hash_key = iter.current().*.key.*.hash();
                var hash_val = iter.current().*.value.*.hash();
                hash = hash +% hash_key +% hash_val;
            }
            return hash;
        }
        bubby::type::SET {
            var set = self.*.set();
            var hash = 0u;
            var iter = std::hash_set_iterator[[value]]::init(set);
            for iter.advance() {
                hash = hash +% iter.current().*.hash();
            }
            return hash;
        }
        }

        std::unreachable(fileof(), lineof());
        return 0;
    }

    func eq(lhs: *value, rhs: *value) bool {
        if lhs.*._type != rhs.*._type {
            return false;
        }

        switch lhs.*._type {
        bubby::type::BOOL {
            return std::eq[[::bool]](&lhs.*._data.bool, &rhs.*._data.bool);
        }
        bubby::type::INT {
            return std::eq[[s64]](&lhs.*._data.int, &rhs.*._data.int);
        }
        bubby::type::NUMBER {
            return std::eq[[f64]](&lhs.*._data.number, &rhs.*._data.number);
        }
        bubby::type::STRING {
            return std::eq[[[]byte]](&lhs.*._data.string, &rhs.*._data.string);
        }
        bubby::type::VECTOR {
            if lhs.*._data.vector.*.count() != rhs.*._data.vector.*.count() {
                return false;
            }
            var lhs_iter = std::slice_iterator[[value]]::init(lhs.*._data.vector.*.data());
            var rhs_iter = std::slice_iterator[[value]]::init(rhs.*._data.vector.*.data());
            for lhs_iter.advance() and rhs_iter.advance() {
                if not std::eq[[value]](lhs_iter.current(), rhs_iter.current()) {
                    return false;
                }
            }
            return true;
        }
        bubby::type::MAP {
            var lhs_map = lhs.*.map();
            var rhs_map = rhs.*.map();
            if lhs_map.*.count() != rhs_map.*.count() {
                return false;
            }
            var lhs_iter = std::hash_map_iterator[[value, value]]::init(lhs_map);
            for lhs_iter.advance() {
                var lhs_current = lhs_iter.current();
                var rhs_current = rhs_map.*.lookup_view(*lhs_current.*.key);
                if rhs_current.is_empty() {
                    return false;
                }
                var rhs_current = rhs_current.value();
                if not std::eq[[value]](lhs_current.*.value, rhs_current.value) {
                    return false;
                }
            }
            return true;
        }
        bubby::type::SET {
            var lhs_set = lhs.*.set();
            var rhs_set = rhs.*.set();
            if lhs_set.*.count() != rhs_set.*.count() {
                return false;
            }
            var lhs_iter = std::hash_set_iterator[[value]]::init(lhs_set);
            for lhs_iter.advance() {
                var lhs_current = lhs_iter.current();
                var rhs_current = rhs_set.*.lookup_view(*lhs_current);
                if rhs_current.is_empty() {
                    return false;
                }
                var rhs_current = rhs_current.value();
                if not std::eq[[value]](lhs_current, rhs_current) {
                    return false;
                }
            }
            return true;
        }
        }

        std::unreachable(fileof(), lineof());
        return false;
    }

    func format(self: *value, writer: std::writer, fmt: []byte) std::result[[void, std::error]] {
        if countof(fmt) != 0 {
            return std::result[[void, std::error]]::init_error(std::error::INVALID_ARGUMENT);
        }

        switch self.*._type {
        bubby::type::BOOL {
            return std::write_format(
                writer,
                "{}",
                (:[]std::formatter)[
                    std::formatter::init[[::bool]](&self.*._data.bool)]);
        }
        bubby::type::INT {
            return std::write_format(
                writer,
                "{}",
                (:[]std::formatter)[
                    std::formatter::init[[s64]](&self.*._data.int)]);
        }
        bubby::type::NUMBER {
            return std::write_format(
                writer,
                "{}",
                (:[]std::formatter)[
                    std::formatter::init[[f64]](&self.*._data.number)]);
        }
        bubby::type::STRING {
            var result = std::write_all(writer, "\"");
            if result.is_error() {
                return result;
            }
            # All non-printable bytes, plus the double quote used to denote the
            # start and end of the string, are printed using escaped hex bytes.
            for i in countof(self.*._data.string) {
                var c = self.*._data.string[i];
                if c == '\"' or c == '\\' or c < ' ' or c > '~' {
                    let DIGITS = (:[]byte)[
                        '0', '1', '2', '3', '4', '5', '6', '7',
                        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
                    ];
                    var hex = (:[]byte)[
                        DIGITS[(:usize)c & 0xF0 >> 4],
                        DIGITS[(:usize)c & 0x0F]
                    ];
                    var result = std::write_format(
                        writer,
                        "\\x{}",
                        (:[]std::formatter)[
                            std::formatter::init[[[]byte]](&hex)]);
                    if result.is_error() {
                        return result;
                    }
                    continue;
                }
                var result = std::write_all(writer, (:[]byte){&c, 1});
                if result.is_error() {
                    return result;
                }
            }
            return std::write_all(writer, "\"");
        }
        bubby::type::VECTOR {
            var result = std::write_all(writer, "[");
            if result.is_error() {
                return result;
            }
            var sep = "";
            var iter = std::slice_iterator[[value]]::init(self.*._data.vector.*.data());
            for iter.advance() {
                var result = std::write_format(
                    writer,
                    "{}{}",
                    (:[]std::formatter)[
                        std::formatter::init[[[]byte]](&sep),
                        std::formatter::init[[value]](iter.current())]);
                if result.is_error() {
                    return result;
                }
                sep = " ";
            }
            return std::write_all(writer, "]");

        }
        bubby::type::MAP {
            var map = self.*.map();
            var result = std::write_all(writer, "{");
            if result.is_error() {
                return result;
            }
            var sep = "";
            var iter = std::hash_map_iterator[[value, value]]::init(map);
            for iter.advance() {
                var result = std::write_format(
                    writer,
                    "{}{} {}",
                    (:[]std::formatter)[
                        std::formatter::init[[[]byte]](&sep),
                        std::formatter::init[[value]](iter.current().*.key),
                        std::formatter::init[[value]](iter.current().*.value)]);
                if result.is_error() {
                    return result;
                }
                sep = " ";
            }
            return std::write_all(writer, "}");
        }
        bubby::type::SET {
            var set = self.*.set();
            var result = std::write_all(writer, "(");
            if result.is_error() {
                return result;
            }
            var sep = "";
            var iter = std::hash_set_iterator[[value]]::init(set);
            for iter.advance() {
                var result = std::write_format(
                    writer,
                    "{}{}",
                    (:[]std::formatter)[
                        std::formatter::init[[[]byte]](&sep),
                        std::formatter::init[[value]](iter.current())]);
                if result.is_error() {
                    return result;
                }
                sep = " ";
            }
            return std::write_all(writer, ")");
        }
        }

        std::unreachable(fileof(), lineof());
        return std::zeroed[[std::result[[void, std::error]]]]();
    }

    func type(self: *value) bubby::type {
        return self.*._type;
    }

    func bool(self: *value) bool {
        assert self.*._type == bubby::type::BOOL;
        return self.*._data.bool;
    }

    func int(self: *value) s64 {
        assert self.*._type == bubby::type::INT;
        return self.*._data.int;
    }

    func number(self: *value) f64 {
        assert self.*._type == bubby::type::NUMBER;
        return self.*._data.number;
    }

    func string(self: *value) []byte {
        assert self.*._type == bubby::type::STRING;
        return self.*._data.string;
    }

    func vector(self: *value) *std::vector[[value]] {
        assert self.*._type == bubby::type::VECTOR;
        return self.*._data.vector;
    }

    func map(self: *value) *std::hash_map[[value, value]] {
        assert self.*._type == bubby::type::MAP;
        return (:*std::hash_map[[value, value]])self.*._data.map;
    }

    func map_insert_int(self: *value, int: s64, val: bubby::value) void {
        var existing = self.*.map().*.insert(value::init_int(int), val);
        if existing.is_value() {
            var existing = existing.value();
            existing.key.fini();
            existing.value.fini();
        }
    }

    func map_lookup_int(self: *value, int: s64) std::optional[[*value]] {
        var optional = self.*.map_lookup_view_int(int);
        if optional.is_empty() {
            return std::optional[[*value]]::EMPTY;
        }
        return std::optional[[*value]]::init_value(optional.value().value);
    }

    func map_xlookup_int(self: *value, int: s64) *value {
        var optional = self.*.map_lookup_int(int);
        return optional.value();
    }

    func map_lookup_view_int(self: *value, int: s64) std::optional[[std::key_value_view[[value, value]]]] {
        var key = (:value){
            ._type = bubby::type::INT,
            ._data = (:typeof(value::_SELF._data)){.int = int},
        };
        return self.*.map().*.lookup_view(key);
    }

    func map_xlookup_view_int(self: *value, int: s64) std::key_value_view[[value, value]] {
        var optional = self.*.map_lookup_view_int(int);
        return optional.value();
    }

    func map_insert_num(self: *value, num: f64, val: bubby::value) void {
        var existing = self.*.map().*.insert(value::init_number(num), val);
        if existing.is_value() {
            var existing = existing.value();
            existing.key.fini();
            existing.value.fini();
        }
    }

    func map_lookup_num(self: *value, num: f64) std::optional[[*value]] {
        var optional = self.*.map_lookup_view_num(num);
        if optional.is_empty() {
            return std::optional[[*value]]::EMPTY;
        }
        return std::optional[[*value]]::init_value(optional.value().value);
    }

    func map_xlookup_num(self: *value, num: f64) *value {
        var optional = self.*.map_lookup_num(num);
        return optional.value();
    }

    func map_lookup_view_num(self: *value, number: f64) std::optional[[std::key_value_view[[value, value]]]] {
        var key = (:value){
            ._type = bubby::type::NUMBER,
            ._data = (:typeof(value::_SELF._data)){.number = number},
        };
        return self.*.map().*.lookup_view(key);
    }

    func map_xlookup_view_num(self: *value, num: f64) std::key_value_view[[value, value]] {
        var optional = self.*.map_lookup_view_num(num);
        return optional.value();
    }

    func map_insert_str(self: *value, str: []byte, val: bubby::value) void {
        var existing = self.*.map().*.insert(value::init_string(str), val);
        if existing.is_value() {
            var existing = existing.value();
            existing.key.fini();
            existing.value.fini();
        }
    }

    func map_lookup_str(self: *value, str: []byte) std::optional[[*value]] {
        var optional = self.*.map_lookup_view_str(str);
        if optional.is_empty() {
            return std::optional[[*value]]::EMPTY;
        }
        return std::optional[[*value]]::init_value(optional.value().value);
    }

    func map_xlookup_str(self: *value, str: []byte) *value {
        var optional = self.*.map_lookup_str(str);
        return optional.value();
    }

    func map_lookup_view_str(self: *value, str: []byte) std::optional[[std::key_value_view[[value, value]]]] {
        var key = (:value){
            ._type = bubby::type::STRING,
            ._data = (:typeof(value::_SELF._data)){.string = str},
        };
        return self.*.map().*.lookup_view(key);
    }

    func map_xlookup_view_str(self: *value, str: []byte) std::key_value_view[[value, value]] {
        var optional = self.*.map_lookup_view_str(str);
        return optional.value();
    }

    func set(self: *value) *std::hash_set[[value]] {
        assert self.*._type == bubby::type::SET;
        return (:*std::hash_set[[value]])self.*._data.set;
    }

    func set_insert(self: *value, val: bubby::value) void {
        var existing = self.*.set().*.insert(val);
        if existing.is_value() {
            var existing = existing.value();
            existing.fini();
        }
    }
}

func _is_whitespace(char: byte) bool {
    return char == ' ' or char == '\t' or char == '\n';
}

struct parse_success {
    var value: bubby::value;
    var index: usize;
}

func parse_bool(str: []byte) std::result[[bubby::parse_success, std::error]] {
    if std::str::eq(str, "true") {
        return std::result[[bubby::parse_success, std::error]]::init_value((:bubby::parse_success){
            .value = value::init_bool(true),
            .index = countof("true"),
        });
    }

    if std::str::eq(str, "false") {
        return std::result[[bubby::parse_success, std::error]]::init_value((:bubby::parse_success){
            .value = value::init_bool(false),
            .index = countof("false"),
        });
    }

    return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
}

func _parse_int_or_number(str: []byte) std::result[[bubby::parse_success, std::error]] {
    if countof(str) == 0 {
        return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
    }

    var cur = 0u;
    var type = bubby::type::INT;
    if str[cur] == '+' or str[cur] == '-' {
        cur = cur + 1;
    }
    if cur != countof(str) and not std::ascii::is_digit(str[cur]) {
        return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
    }
    for cur != countof(str) and (std::ascii::is_digit(str[cur]) or (type == bubby::type::INT and str[cur] == '.')) {
        if str[cur] == '.' {
            type = bubby::type::NUMBER;
            cur = cur + 1;
            continue;
        }
        cur = cur + 1;
    }

    if type == bubby::type::NUMBER {
        var result = f64::init_from_str(str[0:cur]);
        if result.is_error() {
            return std::result[[bubby::parse_success, std::error]]::init_error(result.error());
        }
        return std::result[[bubby::parse_success, std::error]]::init_value((:bubby::parse_success){
            .value = value::init_number(result.value()),
            .index = cur,
        });
    }

    var result = s64::init_from_str(str[0:cur], 10);
    if result.is_error() {
        return std::result[[bubby::parse_success, std::error]]::init_error(result.error());
    }
    return std::result[[bubby::parse_success, std::error]]::init_value((:bubby::parse_success){
        .value = value::init_int(result.value()),
        .index = cur,
    });
}

func parse_int(str: []byte) std::result[[bubby::parse_success, std::error]] {
    var result = bubby::_parse_int_or_number(str);
    if result.is_error() {
        return result;
    }
    var value = result.value().value;
    if value.type() != bubby::type::INT {
        value.fini();
        return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
    }
    return result;
}

func parse_number(str: []byte) std::result[[bubby::parse_success, std::error]] {
    var result = bubby::_parse_int_or_number(str);
    if result.is_error() {
        return result;
    }
    var value = result.value().value;
    if value.type() != bubby::type::NUMBER {
        value.fini();
        return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
    }
    return result;
}

func parse_string(str: []byte) std::result[[bubby::parse_success, std::error]] {
    if countof(str) == 0 {
        return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
    }

    var cur = 0u;
    var buf = std::slice[[byte]]::new(0);
    if cur == countof(str) or str[cur] != '\"' {
        std::slice[[byte]]::delete(buf);
        return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
    }
    cur = cur + 1;
    for cur != countof(str) and str[cur] != '\"' {
        var c = str[cur];
        if c < ' ' or c > '~' {
            std::slice[[byte]]::delete(buf);
            return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
        }
        if c != '\\' {
            buf = std::slice[[byte]]::resize(buf, countof(buf)+1);
            buf[countof(buf)-1] = c;
            cur = cur + 1;
            continue;
        }
        if countof(str) - cur < countof("\\xXX") {
            std::slice[[byte]]::delete(buf);
            return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
        }
        var hex = str[cur:cur+countof("\\xXX")];
        if hex[0] != '\\' or hex[1] != 'x' {
            std::slice[[byte]]::delete(buf);
            return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
        }
        let DIGITS = "0123456789ABCDEF";
        var hi = std::str::find(DIGITS, (:[]byte){&hex[2], 1});
        var lo = std::str::find(DIGITS, (:[]byte){&hex[3], 1});
        if hi.is_empty() or lo.is_empty() {
            std::slice[[byte]]::delete(buf);
            return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
        }
        var c = (:byte)(hi.value() << 4) | (:byte)lo.value();
        buf = std::slice[[byte]]::resize(buf, countof(buf)+1);
        buf[countof(buf)-1] = c;
        cur = cur + 4;
    }
    if cur == countof(str) or str[cur] != '\"' {
        std::slice[[byte]]::delete(buf);
        return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
    }
    cur = cur + 1;
    return std::result[[bubby::parse_success, std::error]]::init_value((:bubby::parse_success){
        .value = (:value){
            ._type = bubby::type::STRING,
            ._data = (:typeof(value::_SELF._data)){.string = buf},
        },
        .index = cur,
    });
}

func parse_vector(str: []byte) std::result[[bubby::parse_success, std::error]] {
    if countof(str) == 0 {
        return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
    }

    var cur = 0u;
    var out = value::init_vector();
    if cur == countof(str) or str[cur] != '[' {
        out.fini();
        return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
    }
    cur = cur + 1;
    for cur != countof(str) {
        # Require space separation between elements or optional space separation before the terminating ']'.
        if out.vector().*.count() != 0 and cur != countof(str) and str[cur] != ']' and not bubby::_is_whitespace(str[cur]) {
            out.fini();
            return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
        }
        for cur != countof(str) and bubby::_is_whitespace(str[cur]) {
            cur = cur + 1;
        }
        if cur != countof(str) and str[cur] == ']' {
            break;
        }

        var result = bubby::parse(str[cur:countof(str)]);
        if result.is_error() {
            out.fini();
            return result;
        }
        cur = cur + result.value().index;
        out.vector().*.push(result.value().value);
    }
    if cur == countof(str) or str[cur] != ']' {
        out.fini();
        return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
    }
    cur = cur + 1;
    return std::result[[bubby::parse_success, std::error]]::init_value((:bubby::parse_success){
        .value = out,
        .index = cur,
    });
}

func parse_map(str: []byte) std::result[[bubby::parse_success, std::error]] {
    if countof(str) == 0 {
        return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
    }

    var cur = 0u;
    var out = value::init_map();
    if cur == countof(str) or str[cur] != '{' {
        out.fini();
        return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
    }
    cur = cur + 1;
    for cur != countof(str) {
        # Require space separation between key-value pairs or optional space separation before the terminating '}'.
        if out.map().*.count() != 0 and cur != countof(str) and str[cur] != '}' and not bubby::_is_whitespace(str[cur]) {
            out.fini();
            return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
        }
        for cur != countof(str) and bubby::_is_whitespace(str[cur]) {
            cur = cur + 1;
        }
        if cur != countof(str) and str[cur] == '}' {
            break;
        }

        var result = bubby::parse(str[cur:countof(str)]);
        if result.is_error() {
            out.fini();
            return result;
        }
        cur = cur + result.value().index;
        var key = result.value().value;

        if out.map().*.contains(key) {
            out.fini();
            key.fini();
            return std::result[[bubby::parse_success, std::error]]::init_error((:std::error)&"duplicate map key");
        }

        # Require space separation between the key and value.
        if cur == countof(str) or not bubby::_is_whitespace(str[cur]) {
            out.fini();
            key.fini();
            return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
        }
        for cur != countof(str) and bubby::_is_whitespace(str[cur]) {
            cur = cur + 1;
        }
        var result = bubby::parse(str[cur:countof(str)]);
        if result.is_error() {
            out.fini();
            key.fini();
            return result;
        }
        cur = cur + result.value().index;
        var val = result.value().value;

        out.map().*.insert(key, val);
    }
    if cur == countof(str) or str[cur] != '}' {
        out.fini();
        return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
    }
    cur = cur + 1;
    return std::result[[bubby::parse_success, std::error]]::init_value((:bubby::parse_success){
        .value = out,
        .index = cur,
    });
}

func parse_set(str: []byte) std::result[[bubby::parse_success, std::error]] {
    if countof(str) == 0 {
        return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
    }

    var cur = 0u;
    var out = value::init_set();
    if cur == countof(str) or str[cur] != '(' {
        out.fini();
        return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
    }
    cur = cur + 1;
    for cur != countof(str) {
        # Require space separation between elements or optional space separation before the terminating ')'.
        if out.set().*.count() != 0 and cur != countof(str) and str[cur] != ')' and not bubby::_is_whitespace(str[cur]) {
            out.fini();
            return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
        }
        for cur != countof(str) and bubby::_is_whitespace(str[cur]) {
            cur = cur + 1;
        }
        if cur != countof(str) and str[cur] == ')' {
            break;
        }

        var result = bubby::parse(str[cur:countof(str)]);
        if result.is_error() {
            out.fini();
            return result;
        }
        cur = cur + result.value().index;
        var val = result.value().value;

        if out.set().*.contains(val) {
            out.fini();
            return std::result[[bubby::parse_success, std::error]]::init_error((:std::error)&"duplicate set element");
        }

        out.set().*.insert(val);
    }
    if cur == countof(str) or str[cur] != ')' {
        out.fini();
        return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
    }
    cur = cur + 1;
    return std::result[[bubby::parse_success, std::error]]::init_value((:bubby::parse_success){
        .value = out,
        .index = cur,
    });
}

func parse(str: []byte) std::result[[bubby::parse_success, std::error]] {
    if countof(str) == 0 {
        return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
    }

    if str[0] == 't' or str[0] == 'f' {
        return bubby::parse_bool(str);
    }

    if str[0] == '+' or str[0] == '-' or std::ascii::is_digit(str[0]) {
        return bubby::_parse_int_or_number(str);
    }

    if str[0] == '\"' {
        return bubby::parse_string(str);
    }

    if str[0] == '[' {
        return bubby::parse_vector(str);
    }

    if str[0] == '{' {
        return bubby::parse_map(str);
    }

    if str[0] == '(' {
        return bubby::parse_set(str);
    }

    return std::result[[bubby::parse_success, std::error]]::init_error(std::error::PARSE_FAILURE);
}
